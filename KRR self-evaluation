# KERNEL RIDGE REGRESSION PROGRAM

import numpy as np
import time as time

from pandas import DataFrame
from sklearn.model_selection import cross_val_score
from sklearn.kernel_ridge import KernelRidge
from sklearn.metrics import make_scorer

data = np.load('data_fold6.npz')
# displays the titles of the files inside the npz file
file_names = data.files
# reason for split is because train_test_subs_X[:i] is tuple not array type
training_set_X = np.concatenate(data['train_valid_x'])
# fluid intelligence at index 3 column of training set
training_set_y = np.concatenate(data['train_valid_y'])[:, 3]

print('Data Loaded')

alpha_vals = [1000, 1128, 1256, 1384, 1512]

# creating a dataframe to store results
temp_scores = np.zeros((1,5))
results = DataFrame(data = temp_scores, columns = alpha_vals, index = ['score'])

def pcc_score(y, y_pred):
    return np.corrcoef(y_pred, y)[1][0]
pcc_scorer = make_scorer(pcc_score)

def get_alpha(dataframe, val):
    for i in dataframe.columns:
        if np.any(dataframe[i][0] == val):
            return i
    return None

def indiv_score(alpha_vals, results):
    for alpha_input in alpha_vals:
        start = time.time()
        krr = KernelRidge(alpha = alpha_input)
        cvs = cross_val_score(scoring = pcc_scorer, estimator = krr, X = training_set_X, y = training_set_y, cv = 5)
        results[alpha_input] = cvs.mean()
        end = time.time()
        duration = end - start
        print(alpha_input, cvs.mean(), duration)
    
    return results

# if the difference betweeen 2 consec values are more than 1, continue the loop
	# refreshes the dataframe
	# evaluates the scores for each alpha
	# stores in the dataframe
	# finds the best score
	# create new dataframe and start over

def best_alpha(alpha_vals):
    
    temp_scores = np.zeros((1,5))
    results = DataFrame(data = temp_scores, columns = alpha_vals, index = ['score'])
    
    if alpha_vals[1] - alpha_vals[0] > 1:
        
        temp_results = indiv_score(alpha_vals, results)
        best_score = temp_results.max(axis = 1)
        temp_alpha = get_alpha(temp_results, best_score)
        
        print(temp_results)
        print(best_score)
        print(temp_alpha)
        
        half_range = alpha_vals[1] - alpha_vals[0]
        range_min, range_max = temp_alpha - half_range, temp_alpha + half_range

        # if the results are on the extreme ends
        if temp_alpha == alpha_vals[0] or temp_alpha == alpha[-1]:
            new_interval = half_range
            new_alpha_vals = np.arange(alpha_vals[1] - new_interval * 4, alpha_vals[1] + 1, new_interval)
            
        else:
            new_interval = half_range / 2
            new_alpha_vals = np.arange(range_min, (range_max + 1), new_interval)
        
        print(new_interval)
        print(range_min, range_max)
        print(new_alpha_vals)

        best_alpha(new_alpha_vals)

    else:
        temp_results = indiv_score(alpha_vals, results)
        best_score = temp_results.max(axis = 1)
        temp_alpha = get_alpha(temp_results, best_score)
        print(temp_results)
        print(best_score, temp_alpha)

print('Starting analysis')
best_alpha(alpha_vals)
